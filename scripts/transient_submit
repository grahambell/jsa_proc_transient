#!/usr/bin/env starperl

use JAC::Setup qw/omp sybase/;

use strict;
use warnings;

use Getopt::Long;
use IO::File;
use File::Basename;
use Alien::Taco;

use JSA::Submission qw/
    %BAD_OBSIDSS %JUNK_OBSIDSS
    echo_messages find_observations
    log_message prepare_archive_db write_log_file/;
use JSA::Proc qw/add_jsa_proc_jobs create_obsinfo_hash/;
use OMP::Info::Obs;
use OMP::Constants qw/:obs/;

my ($ut, $observation, $dry_run, $gbs, $ec, $reduction_str, $offset_file);
die 'Could not process command line options'
    unless GetOptions(
        'dry-run'     => \$dry_run,
        'ut=s'        => \$ut,
        'obs=s'       => \$observation,
        'gbs'         => \$gbs,
        'ec'          => \$ec,
        'reduction=s' => \$reduction_str,
        'offsets=s'   => \$offset_file,
    );

my (@projects, @reductions, $priority, %project_objects);

if ($gbs) {
    my $taco = new Alien::Taco(lang => 'python');
    $taco->import_module('jsa_proc_transient.gbs');
    my $gbs_objects = $taco->get_value('jsa_proc_transient.gbs.gbs_objects');

    foreach my $object (values %$gbs_objects) {
        foreach my $proj_obs (@$object) {
            my ($project, $object) = @$proj_obs;
            $project_objects{$project} //= {};
            $project_objects{$project}->{$object} = 1;
        }
    }

    @projects = keys %project_objects;
    @reductions = qw/R1 R2/;
    $priority = -100;
}
elsif ($ec) {
    @projects = qw/M16BEC30/;
    @reductions = qw/R1 R2 R3 R4/;
    $priority = -100;

    die 'Please specify observation number for E&C data submission'
        unless defined $observation;
}
else {
    @projects = qw/M16AL001/;
    @reductions = qw/R1 R2 R3 R4/;
    $priority = 100;
}

if (defined $reduction_str) {
    @reductions = split ',', $reduction_str;
}

my $tag_extra = '';
my $offset = undef;
if (defined $offset_file) {
    $offset = read_offset_file($offset_file);
    $tag_extra = '-K';
}

my $task = 'lap-transient';
my $only_info = 0;

die 'UT date not specified' unless defined $ut;

echo_messages(1);

prepare_archive_db();

foreach my $project (@projects) {
    my ($mode, $grp) = find_observations(
        $ut, $project, $priority, 'transient_submit');

    if (scalar(@{$grp->obs}) == 0) {
        log_message("No observations were retrieved from the database.\n");
    }
    else {
        log_message(scalar(@{$grp->obs}) .
                    " observations were retrieved from the database.\n\n");

        my %groups;

        foreach my $obs ($grp->obs) {
            next if $obs->status == OMP__OBS_JUNK;

            if (defined $observation) {
                next unless $obs->runnr() == $observation;
            }

            my @files = ();
            my @obsinfo = ();
            my @offset_args = ();

            for my $subsys ($obs->subsystems()) {
                my @all_obsidss = $subsys->obsidss;
                my $obsidss = $all_obsidss[0];

                die "Error determining an OBSIDSS for an observation"
                    unless defined $obsidss;

                next if exists $JUNK_OBSIDSS{$obsidss};

                my $subsyshdr = $subsys->hdrhash();
                my $object = $subsyshdr->{'OBJECT'};

                if (scalar keys %project_objects) {
                    unless (exists $project_objects{$project}->{$object}) {
                        log_message("Skipping unwanted object $object.\n");
                        next;
                    }
                }

                if (defined $offset) {
                    my $offset_key = sprintf(
                        '%8d_%05d',
                        $subsyshdr->{'UTDATE'},
                        $subsyshdr->{'OBSNUM'});

                    unless (exists $offset->{$offset_key}) {
                        log_message("Skipping obs without offset: $obsidss\n");
                        next;
                    }

                    my $offset_radec = $offset->{$offset_key};
                    @offset_args = ('--dra', $offset_radec->[0],
                                    '--ddec', $offset_radec->[1]);
                }

                push @obsinfo, create_obsinfo_hash($obs, $subsyshdr);

                push @files, map {basename($_)} $subsys->filename();
            }

            if (scalar @files) {
                # Combine arguments in case we (in future) have multiple sets.
                my @extra_args = @offset_args;

                foreach my $reduction (@reductions) {
                    my $tag = $task . "-" . $obs->obsid
                                    . "-" . $reduction
				    . $tag_extra;

                    foreach my $obsinfo (@obsinfo) {
                        $obsinfo->{'association'} = $tag;
                    }

                    my $params = $reduction;

                    if (@extra_args) {
                        $params .= ' -- '. join(' ', @extra_args);
                    }

                    $groups{$tag} = {
                        mode => 'obs',
                        task => $task,
                        drparams => $params,
                        files => \@files,
                        obsinfolist => \@obsinfo,
                    };
                }
            }
        }

        add_jsa_proc_jobs(\%groups, 'obs', $priority, $only_info, $dry_run);
    }
}

exit;


sub read_offset_file {
    my $filename = shift;
    my %offset = ();
    my $fh = new IO::File($filename, 'r');

    foreach (<$fh>) {
        chomp;
        next if /^REF/ or /^---/;
        my (undef, $id, $dra, $ddec) = split /\t/;
        die 'did not understand ID' unless $id =~ /_(\d{8}_\d{5})$/;
        $offset{$1} = [$dra, $ddec];
    }

    $fh->close();

    return \%offset;
}
